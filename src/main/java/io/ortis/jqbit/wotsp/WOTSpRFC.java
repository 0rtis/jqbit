package io.ortis.jqbit.wotsp;

import io.ortis.jqbit.HashFunction;
import io.ortis.jqbit.Utils;

/**
 * Implementation of the Winternitz One-Time Signature Plus (WOTS+) as specified in the RFC 8391.
 * <p>
 * See RFC 8391 for more details.
 */
public class WOTSpRFC
{
	/**
	 * From RFC 8391:
	 * <p>
	 * A WOTS+ key pair defines a virtual structure that consists of len
	 * hash chains of length w. The len n-byte strings in the private key
	 * each define the start node for one hash chain. The public key
	 * consists of the end nodes of these hash chains. Therefore, like the
	 * private key, the public key is also a length len array of n-byte
	 * strings. To compute the hash chain, the chaining function (Algorithm
	 * 2) is used. An OTS hash address ADRS and a seed SEED have to be
	 * provided by the calling algorithm. This address will encode the
	 * address of the WOTS+ key pair within a greater structure. Hence, a
	 * WOTS+ algorithm MUST NOT manipulate any parts of ADRS except for the
	 * last three 32-bit words. Please note that the SEED used here is
	 * public information also available to a verifier. The following
	 * pseudocode (Algorithm 4) describes an algorithm for generating the
	 * public key pk, where sk is the private key.
	 * <p>
	 * Note: Although SEED is public, it is critical for security
	 * that it is generated using a good entropy source
	 *
	 * @param config:            WOTS+ parameters
	 * @param privateKey:        secret byte array of length LEN
	 * @param publicSeed:        public byte array of length N sampled from a secure source of randomness
	 * @param adrs:              data structure
	 * @param destination:       byte array with at least LEN * N slot available to store the resulting public key
	 * @param destinationOffset: byte array offset
	 */
	public static void publicKey(final WOTSpConfig config, final byte[] privateKey, final byte[] publicSeed, final Adrs adrs, final byte[] destination,
			final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		final int n = config.getN();
		final int len = config.getLen();
		final int wm1 = config.getW() - 1;

		for(int i = 0; i < len; i++)
		{
			final int offset = i * n;
			adrs.setChainAddress(i);
			chain(config, privateKey, offset, 0, wm1, publicSeed, adrs, destination, destinationOffset + offset);
		}
	}

	/**
	 * From RFC 8391:
	 * <p>
	 * A WOTS+ signature is a length len array of n-byte strings. The WOTS+
	 * signature is generated by mapping a message to len integers between 0
	 * and w - 1. To this end, the message is transformed into len_1 base w
	 * numbers using the base_w function defined in Section 2.6. Next, a
	 * checksum is computed and appended to the transformed message as len_2
	 * base w numbers using the base_w function. Note that the checksum may
	 * reach a maximum integer value of len_1 * (w - 1) * 2^8 and therefore
	 * depends on the parameters n and w. For the parameter sets given in
	 * Section 5, a 32-bit unsigned integer is sufficient to hold the
	 * checksum. If other parameter settings are used, the size of the
	 * variable holding the integer value of the checksum MUST be
	 * sufficiently large. Each of the base w integers is used to select a
	 * node from a different hash chain. The signature is formed by
	 * concatenating the selected nodes. An OTS hash address ADRS and a
	 * seed SEED have to be provided by the calling algorithm. This address
	 * will encode the address of the WOTS+ key pair within a greater
	 * structure. Hence, a WOTS+ algorithm MUST NOT manipulate any parts of
	 * ADRS except for the last three 32-bit words. Please note that the
	 * SEED used here is public information also available to a verifier.
	 * The pseudocode for signature generation is shown below (Algorithm 5),
	 * where M is the message and sig is the resulting signature.
	 *
	 * @param config:            WOTS+ parameters
	 * @param msg:               message of length N to sign
	 * @param privateKey:        secret byte array of length LEN
	 * @param publicSeed:        public byte array of length N sampled from a secure source of randomness
	 * @param adrs:              data structure
	 * @param destination:       byte array with at least LEN slot available to store the resulting signature
	 * @param destinationOffset: byte array offset
	 */
	public static void sign(final WOTSpConfig config, final byte[] msg, final byte[] privateKey, final byte[] publicSeed, final Adrs adrs, final byte[] destination,
			final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{

		final int n = config.getN();
		final int len = config.getLen();

		final int[] hashLengths = new int[len];
		hashLengths(config, msg, hashLengths, 0);

		/*
		int csum = 0;
		final int[] hashLengths = new int[len];// msg in base w (len1) + checksum in base w (len2)

		// Convert message to base w
		basew(config, msg, hashLengths, 0, len1);


		{// Checksum
			// Compute checksum
			for(int i = 0; i < len1; i++)
				csum += wm1 - hashLengths[i];

			// Convert csum to base w
			csum = csum << (8 - ((len2 * logw) % 8));

			// len_2_bytes = ceil((len2 * logw) / 8);
			final byte[] len2Bytes = ByteUtils.zToBytes(csum, (len2 * logw + 7 ) / 8);

			// msg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);

			basew(config, len2Bytes, hashLengths, len1, len2);
		}*/

		for(int i = 0; i < len; i++)
		{
			final int offset = i * n;
			adrs.setChainAddress(i);
			chain(config, privateKey, offset, 0, hashLengths[i], publicSeed, adrs, destination, destinationOffset + offset);
		}
	}

	/**
	 * From RFC 8391:
	 * <p>
	 * In order to verify a signature sig on a message M, the verifier
	 * computes a WOTS+ public key value from the signature. This can be
	 * done by "completing" the chain computations starting from the
	 * signature values, using the base w values of the message hash and its
	 * checksum. This step, called WOTS_pkFromSig, is described below in
	 * Algorithm 6. The result of WOTS_pkFromSig is then compared to the
	 * given public key. If the values are equal, the signature is
	 * accepted. Otherwise, the signature MUST be rejected. An OTS hash
	 * address ADRS and a seed SEED have to be provided by the calling
	 * algorithm. This address will encode the address of the WOTS+ key
	 * pair within a greater structure. Hence, a WOTS+ algorithm MUST NOT
	 * manipulate any parts of ADRS except for the last three 32-bit words.
	 * Please note that the SEED used here is public information also
	 * available to a verifier.
	 *
	 * @param config:            WOTS+ parameters
	 * @param msg:               message of length N to sign
	 * @param signature:         signature of length LEN * N
	 * @param publicSeed:        public byte array of length N sampled from a secure source of randomness
	 * @param adrs:              data structure
	 * @param destination:       byte array with at least LEN slot available to store the resulting signature
	 * @param destinationOffset: byte array offset
	 */
	public static void signatureToPublicKey(final WOTSpConfig config, final byte[] msg, final byte[] signature, final byte[] publicSeed, final Adrs adrs,
			final byte[] destination, final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		final int n = config.getN();
		final int wm1 = config.getW() - 1;
		final int len = config.getLen();

		final int[] hashLengths = new int[len];
		hashLengths(config, msg, hashLengths, 0);

		for(int i = 0; i < len; i++)
		{
			final int offset = i * n;
			adrs.setChainAddress(i);
			chain(config, signature, offset, hashLengths[i], wm1 - hashLengths[i], publicSeed, adrs, destination, destinationOffset + offset);
		}
	}

	/**
	 * From RFC 8391:
	 * <p>
	 * The chaining function (Algorithm 2) computes an iteration of F on an
	 * n-byte input using outputs of PRF. It takes an OTS hash address as
	 * input. This address will have the first six 32-bit words set to
	 * encode the address of this chain. In each iteration, PRF is used to
	 * generate a key for F and a bitmask that is XORed to the intermediate
	 * result before it is processed by F. In the following, ADRS is a
	 * 32-byte OTS hash address as specified in Section 2.5 and SEED is an
	 * n-byte string. To generate the keys and bitmasks, PRF is called with
	 * SEED as key and ADRS as input. The chaining function takes as input
	 * an n-byte string X, a start index i, a number of steps s, as well as
	 * ADRS and SEED. The chaining function returns as output the value
	 * obtained by iterating F for s times on input X, using the outputs of
	 * PRF.
	 * <p>
	 * Input: Input string X, start index i, number of steps s,	seed SEED, address ADRS
	 * Output: value of F iterated s times on X
	 */
	public static void rchain(final WOTSpConfig config, final byte[] x, final int xOffset, final int i, final int s, final byte[] publicSeed, final Adrs adrs,
			final byte[] destination, final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		final int n = config.getN();
		if(s == 0)
		{
			System.arraycopy(x, xOffset, destination, destinationOffset, n);
			return;
		}

		if((i + s) > (config.getW() - 1))
		{
			throw new RuntimeException();
			//return;
		}

		byte[] tmp = new byte[n];
		rchain(config, x, xOffset, i, s - 1, publicSeed, adrs, tmp, 0);
		adrs.setHashAddress(i + s - 1);
		adrs.setKeyAndMask(0);

		/* KEY = PRF(SEED, ADRS) */
		final byte[] key = new byte[n];
		prf(config, publicSeed, 0, publicSeed.length, adrs.toBytes(), 0, Adrs.LENGTH, key, 0);

		adrs.setKeyAndMask(1);

		/* BM = PRF(SEED, ADRS) */
		final byte[] bm = new byte[n];
		prf(config, publicSeed, 0, publicSeed.length, adrs.toBytes(), 0, Adrs.LENGTH, bm, 0);

		/* tmp = F(KEY, tmp XOR BM); */
		for(int j = 0; j < n; j++)
			tmp[j] = (byte) (tmp[j] ^ bm[j]);
		f(config, key, 0, key.length, tmp, 0, tmp.length, bm, 0);

		System.arraycopy(tmp, 0, destination, destinationOffset, n);
	}

	public static void chain(final WOTSpConfig config, final byte[] x, final int xOffset, final int index, final int s, final byte[] publicSeed, final Adrs adrs,
			final byte[] destination, final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		final int n = config.getN();
		final int w = config.getW();

		final byte[] key = new byte[n];
		final byte[] bm = new byte[n];
		final byte[] xorTmpBm = new byte[n];
		final byte[] tmp = new byte[n];
		System.arraycopy(x, xOffset, tmp, 0, tmp.length);

		/* Use for loop instead of recursive function */
		for(int i = index; i < (index + s) && i < w; i++)
		{
			adrs.setHashAddress(i);
			adrs.setKeyAndMask(0);

			/* KEY = PRF(SEED, ADRS) */
			prf(config, publicSeed, 0, n, adrs.toBytes(), 0, Adrs.LENGTH, key, 0);

			adrs.setKeyAndMask(1);

			/* BM = PRF(SEED, ADRS) */
			prf(config, publicSeed, 0, n, adrs.toBytes(), 0, Adrs.LENGTH, bm, 0);

			/* tmp = F(KEY, tmp XOR BM); */
			for(int j = 0; j < n; j++)
				xorTmpBm[j] = (byte) (tmp[j] ^ bm[j]);

			f(config, key, 0, key.length, xorTmpBm, 0, xorTmpBm.length, tmp, 0);

			//System.arraycopy(bm, 0, destination, destinationOffset, n);
		}

		System.arraycopy(tmp, 0, destination, destinationOffset, n);
	}

	/**
	 * Compute the hash lengths from a message
	 *
	 * @param config:            WOTS+ parameters
	 * @param msg:               message of length N to sign
	 * @param destination:       byte array with at least LEN slot available
	 * @param destinationOffset: byte array offset
	 */
	public static void hashLengths(final WOTSpConfig config, final byte[] msg, final int[] destination, final int destinationOffset)
	{
		final int w = config.getW();
		final int wm1 = w - 1;
		final int logw = config.getLogW();
		final int len1 = config.getLen1();
		final int len2 = config.getLen2();


		int csum = 0;
		//final int[] hashLengths = new int[len];// msg in base w (len1) + checksum in base w (len2)

		// Convert message to base w
		basew(config, msg, destination, destinationOffset, len1);

		{/* Checksum */

			// Compute checksum
			for(int i = 0; i < len1; i++)
				csum += wm1 - destination[destinationOffset + i];

			// Convert csum to base w
			// csum = csum << (8 - ((len2 * logw) % 8));
			csum = csum << (8 - ((len2 * logw) & 7));

			// len_2_bytes = ceil((len2 * logw) / 8);
			//final byte[] len2Bytes = ByteUtils.zToBytes(csum, (len2 * logw + 7/* ceil trick */) / 8);
			final byte[] len2Bytes = Utils.zToBytes(csum, ceilDiv(len2 * logw, 8));

			// msg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);

			basew(config, len2Bytes, destination, destinationOffset + len1, len2);
		}

	}

	/**
	 * From RFC 8391: F = SHA2-256(toByte(0, 32) || KEY || M)
	 * <p>
	 * can be generalized to F = Hash(toByte(0, N) + KEY + M).
	 */
	public static void f(final WOTSpConfig config, final byte[] key, final int keyOffset, final int keyLength, final byte[] m, final int mOffset, final int mLength,
			final byte[] destination, final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		functionTemplate(config, 0, key, keyOffset, keyLength, m, mOffset, mLength, destination, destinationOffset);
	}

	/**
	 * From RFC 8391: PRF = SHA2-256(toByte(3, 32) || KEY || M).
	 * <p>
	 * can be generalized to PRF = Hash(toByte(3, N) + KEY + M).
	 */
	public static void prf(final WOTSpConfig config, final byte[] key, final int keyOffset, final int keyLength, final byte[] m, final int mOffset, final int mLength,
			final byte[] destination, final int destinationOffset)
			throws HashFunction.Instance.HashFunctionException
	{
		functionTemplate(config, 3, key, keyOffset, keyLength, m, mOffset, mLength, destination, destinationOffset);
	}

	public static void functionTemplate(final WOTSpConfig config, final int cte, final byte[] key, final int keyOffset, final int keyLength, final byte[] m,
			final int mOffset, final int mLength, final byte[] destination, final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		final int n = config.getN();
		final byte[] buffer = new byte[n + keyLength + mLength];

		System.arraycopy(Utils.zToBytes(cte, n), 0, buffer, 0, n);
		System.arraycopy(key, keyOffset, buffer, n, keyLength);
		System.arraycopy(m, mOffset, buffer, n + keyLength, mLength);

		final HashFunction hashFunction = config.getHashFunction();
		final HashFunction.Instance hasher = hashFunction.newInstance();
		hasher.update(buffer);
		hasher.digest(buffer);
		System.arraycopy(buffer, 0, destination, destinationOffset, hashFunction.digestLength());
	}

	public static int ceilDiv(final int a, final int b)
	{
		return (a - 1) / b + 1;
	}

	public static int floorDiv(final int a, final int b)
	{
		return Math.floorDiv(a, b);
	}

	public static void basew(final WOTSpConfig config, final byte[] x, final int[] destination, final int destinationOffset, final int destinationLength)
	{
		final int w = config.getW();
		final int logW = config.getLogW();

		int in = 0;
		int out = 0;
		int total = 0;
		int bits = 0;

		for(int consumed = 0; consumed < destinationLength; consumed++)
		{
			if(bits == 0)
			{
				total = x[in];
				in++;
				bits += 8;
			}
			bits -= logW;
			destination[destinationOffset + out] = (total >> bits) & (w - 1);
			out++;
		}
	}

	public static void inflatePrivateKey(final WOTSpConfig config, final byte[] compactPrivateKey, final int compactPrivateKeyOffset, final byte[] destination,
			final int destinationOffset) throws HashFunction.Instance.HashFunctionException
	{
		final int len = config.getLen();
		final int n = config.getN();

		for(int i = 0; i < len; i++)
		{
			final byte[] cte = Utils.zToBytes(i, n);
			prf(config, compactPrivateKey, compactPrivateKeyOffset, n, cte, 0, cte.length, destination, i * n + destinationOffset);
		}
	}
}
